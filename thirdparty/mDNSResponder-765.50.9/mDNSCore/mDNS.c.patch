diff --git a/thirdparty/mDNSResponder-765.50.9/mDNSCore/mDNS.c b/thirdparty/mDNSResponder-765.50.9/mDNSCore/mDNS.c
index a58a6c1a..7916d6e2 100755
--- a/Build/mDNS/mDNS.c
+++ b/Build/mDNS/mDNS.c
@@ -29,6 +29,7 @@
 #include "dnssec.h"
 #include "anonymous.h"
 
+#ifndef DEFINE_WINDOWS_UNIVERSAL // cannot build as c++ on winrt arm so def it out...
 // Disable certain benign warnings with Microsoft compilers
 #if (defined(_MSC_VER))
 // Disable "conditional expression is constant" warning for debug macros.
@@ -2279,7 +2280,7 @@ mDNSlocal mDNSu16 CheckSum(const void *const data, mDNSs32 length, mDNSu32 sum)
     while (length > 0) { length -= 2; sum += *ptr++; }
     sum = (sum & 0xFFFF) + (sum >> 16);
     sum = (sum & 0xFFFF) + (sum >> 16);
-    return(sum != 0xFFFF ? sum : 0);
+    return (mDNSu16)(sum != 0xFFFF ? sum : 0);
 }
 
 mDNSlocal mDNSu16 IPv6CheckSum(const mDNSv6Addr *const src, const mDNSv6Addr *const dst, const mDNSu8 protocol, const void *const data, const mDNSu32 length)
@@ -2288,9 +2289,9 @@ mDNSlocal mDNSu16 IPv6CheckSum(const mDNSv6Addr *const src, const mDNSv6Addr *co
     ph.src = *src;
     ph.dst = *dst;
     ph.len.b[0] = length >> 24;
-    ph.len.b[1] = length >> 16;
-    ph.len.b[2] = length >> 8;
-    ph.len.b[3] = length;
+    ph.len.b[1] = (mDNSu8)(length >> 16);
+    ph.len.b[2] = (mDNSu8)(length >> 8);
+    ph.len.b[3] = (mDNSu8)length;
     ph.pro.b[0] = 0;
     ph.pro.b[1] = 0;
     ph.pro.b[2] = 0;
@@ -2307,9 +2308,25 @@ mDNSlocal void SendNDP(mDNS *const m, const mDNSu8 op, const mDNSu8 flags, const
     // Some recipient hosts seem to ignore Neighbor Solicitations if the IPv6-layer destination address is not the
     // appropriate IPv6 solicited node multicast address, so we use that IPv6-layer destination address, even though
     // at the Ethernet-layer we unicast the packet to the intended target, to avoid wasting network bandwidth.
-    const mDNSv6Addr mc = { { 0xFF,0x02,0x00,0x00, 0,0,0,0, 0,0,0,1, 0xFF,tpa->b[0xD],tpa->b[0xE],tpa->b[0xF] } };
+    mDNSv6Addr mc;
     const mDNSv6Addr *const v6dst = (op == NDP_Sol) ? &mc : tpa;
     NetworkInterfaceInfo *intf = FirstInterfaceForID(m, rr->resrec.InterfaceID);
+    mc.b[0] = 0xFF;
+    mc.b[1] = 0x02;
+    mc.b[2] = 0x00;
+    mc.b[3] = 0x00;
+    mc.b[4] = 0;
+    mc.b[5] = 0;
+    mc.b[6] = 0;
+    mc.b[7] = 0;
+    mc.b[8] = 0;
+    mc.b[9] = 0;
+    mc.b[10] = 0;
+    mc.b[11] = 1;
+    mc.b[12] = 0xFF;
+    mc.b[13] = tpa->b[0xD];
+    mc.b[14] = tpa->b[0xE];
+    mc.b[15] = tpa->b[0xF];
     if (!intf) { LogMsg("SendNDP: No interface with InterfaceID %p found %s", rr->resrec.InterfaceID, ARDisplayString(m,rr)); return; }
 
     // 0x00 Destination address
@@ -2378,7 +2395,7 @@ mDNSlocal void SendNDP(mDNS *const m, const mDNSu8 op, const mDNSu8 flags, const
     }
 
     // 0x4E or 0x56 Total NDP Packet length 78 or 86 bytes
-    m->omsg.data[0x13] = ptr - &m->omsg.data[0x36];     // Compute actual length
+    m->omsg.data[0x13] = (mDNSu8)(ptr - &m->omsg.data[0x36]);   // Compute actual length
     checksum.NotAnInteger = ~IPv6CheckSum(spa, v6dst, 0x3A, &m->omsg.data[0x36], m->omsg.data[0x13]);
     m->omsg.data[0x38] = checksum.b[0];
     m->omsg.data[0x39] = checksum.b[1];
@@ -5301,31 +5318,36 @@ mDNSexport mDNSs32 mDNS_Execute(mDNS *const m)
         if (m->NumFailedProbes && m->timenow - m->ProbeFailTime >= mDNSPlatformOneSecond * 10) m->NumFailedProbes = 0;
 
         // 3. Purge our cache of stale old records
-        if (m->rrcache_size && m->timenow - m->NextCacheCheck >= 0)
+        if (m->timenow - m->NextCacheCheck >= 0)
         {
             mDNSu32 numchecked = 0;
             m->NextCacheCheck = m->timenow + 0x3FFFFFFF;
-            for (slot = 0; slot < CACHE_HASH_SLOTS; slot++)
+            if (m->rrcache_size)
             {
-                if (m->timenow - m->rrcache_nextcheck[slot] >= 0)
+                for (slot = 0; slot < CACHE_HASH_SLOTS; slot++)
                 {
-                    CacheGroup **cp = &m->rrcache_hash[slot];
-                    m->rrcache_nextcheck[slot] = m->timenow + 0x3FFFFFFF;
-                    while (*cp)
+                    if (m->timenow - m->rrcache_nextcheck[slot] >= 0)
                     {
-                        debugf("m->NextCacheCheck %4d Slot %3d %##s", numchecked, slot, *cp ? (*cp)->name : (domainname*)"\x04NULL");
-                        numchecked++;
-                        CheckCacheExpiration(m, slot, *cp);
-                        if ((*cp)->members) cp=&(*cp)->next;
-                        else ReleaseCacheGroup(m, cp);
+                        CacheGroup **cp = &m->rrcache_hash[slot];
+                        m->rrcache_nextcheck[slot] = m->timenow + 0x3FFFFFFF;
+                        while (*cp)
+                        {
+                            debugf("m->NextCacheCheck %4d Slot %3d %##s", numchecked, slot, *cp ? (*cp)->name : (domainname *)"\x04NULL");
+                            numchecked++;
+                            CheckCacheExpiration(m, slot, *cp);
+                            if ((*cp)->members)
+                                cp = &(*cp)->next;
+                            else
+                                ReleaseCacheGroup(m, cp);
+                        }
                     }
+                    // Even if we didn't need to actually check this slot yet, still need to
+                    // factor its nextcheck time into our overall NextCacheCheck value
+                    if (m->NextCacheCheck - m->rrcache_nextcheck[slot] > 0)
+                        m->NextCacheCheck = m->rrcache_nextcheck[slot];
                 }
-                // Even if we didn't need to actually check this slot yet, still need to
-                // factor its nextcheck time into our overall NextCacheCheck value
-                if (m->NextCacheCheck - m->rrcache_nextcheck[slot] > 0)
-                    m->NextCacheCheck = m->rrcache_nextcheck[slot];
+                debugf("m->NextCacheCheck %4d checked, next in %d", numchecked, m->NextCacheCheck - m->timenow);
             }
-            debugf("m->NextCacheCheck %4d checked, next in %d", numchecked, m->NextCacheCheck - m->timenow);
         }
 
         if (m->timenow - m->NextScheduledSPS >= 0)
@@ -13746,7 +13768,7 @@ mDNSlocal mDNSBool mDNS_IdUsedInQuestionsList(mDNS * const m, mDNSOpaque16 id)
 
 mDNSexport mDNSOpaque16 mDNS_NewMessageID(mDNS * const m)
 {
-    mDNSOpaque16 id;
+    mDNSOpaque16 id = mDNSOpaque16fromIntVal(0);
     int i;
 
     for (i=0; i<10; i++)
@@ -15256,3 +15278,68 @@ mDNSexport void mDNS_FinalExit(mDNS *const m)
 
     LogInfo("mDNS_FinalExit: done");
 }
+
+#else // DEFINE_WINDOWS_UNIVERSAL
+
+mDNSexport mStatus mDNS_Init(mDNS *const /*m*/, mDNS_PlatformSupport *const /*p*/,
+                             CacheEntity * /*rrcachestorage*/, mDNSu32 /*rrcachesize*/,
+                             mDNSBool /*AdvertiseLocalAddresses*/, mDNSCallback * /*Callback*/, void * /*Context*/)
+{
+    return mStatus_NoError;
+}
+
+mDNSexport void mDNS_StartExit(mDNS *const /*m*/)
+{
+}
+
+mDNSexport void mDNS_FinalExit(mDNS *const /*m*/)
+{
+}
+
+mDNSexport mDNSs32 mDNS_Execute(mDNS *const /*m*/)
+{
+    return mStatus_NoError;
+}
+
+mDNSexport mStatus mDNS_RegisterService(mDNS *const /*m*/, ServiceRecordSet * /*sr*/,
+                                        const domainlabel *const /*name*/, const domainname *const /*type*/, const domainname *const /*domain*/,
+                                        const domainname *const /*host*/, mDNSIPPort /*port*/, const mDNSu8 /*txtinfo*/[], mDNSu16 /*txtlen*/,
+                                        AuthRecord * /*SubTypes*/, mDNSu32 /*NumSubTypes*/,
+                                        mDNSInterfaceID /*InterfaceID*/, mDNSServiceCallback /*Callback*/, void * /*Context*/, mDNSu32 /*flags*/)
+{
+    return mStatus_NoError;
+}
+
+mDNSexport mStatus mDNS_RenameAndReregisterService(mDNS *const /*m*/, ServiceRecordSet *const /*sr*/, const domainlabel * /*newname*/)
+{
+    return mStatus_NoError;
+}
+
+mDNSexport mStatus mDNS_DeregisterService_drt(mDNS *const /*m*/, ServiceRecordSet * /*sr*/, mDNS_Dereg_type /*drt*/)
+{
+    return mStatus_NoError;
+}
+
+mDNSexport void mDNS_SetFQDN(mDNS *const /*m*/)
+{
+}
+
+mDNSexport mStatus mDNS_RegisterInterface(mDNS *const /*m*/, NetworkInterfaceInfo * /*set*/, mDNSBool /*flapping*/)
+{
+    return mStatus_NoError;
+}
+
+mDNSexport void mDNS_DeregisterInterface(mDNS *const /*m*/, NetworkInterfaceInfo * /*set*/, mDNSBool /*flapping*/)
+{
+}
+
+mDNSexport void mDNSCoreInitComplete(mDNS *const /*m*/, mStatus /*result*/)
+{
+}
+
+mDNSexport void mDNSCoreReceive(mDNS *const /*m*/, void *const /*pkt*/, const mDNSu8 *const /*end*/,
+                                const mDNSAddr *const /*srcaddr*/, const mDNSIPPort /*srcport*/, const mDNSAddr * /*dstaddr*/, const mDNSIPPort /*dstport*/,
+                                const mDNSInterfaceID /*InterfaceID*/)
+{
+}
+#endif //DEFINE_WINDOWS_UNIVERSAL
\ No newline at end of file
